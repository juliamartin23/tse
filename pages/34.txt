<<<<<<< HEAD
https://thayer.github.io/engs50/Notes/cohesion/
2
11260
=======
<<<<<<< HEAD
https://thayer.github.io/engs50/Notes/iterators/
2
31800
=======
https://thayer.github.io/engs50/Notes/cohesion/
2
11260
>>>>>>> 985afc6cf80cf3f1b063d810d5574da861fac1cf
>>>>>>> 384f1e5bd435ca42f571d4856ac38fdd79014ca8
<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<<<<<<< HEAD
  <title>Cohesion and coupling</title>
=======
<<<<<<< HEAD
  <title>Iterators</title>
=======
  <title>Cohesion and coupling</title>
>>>>>>> 985afc6cf80cf3f1b063d810d5574da861fac1cf
>>>>>>> 384f1e5bd435ca42f571d4856ac38fdd79014ca8
  <meta name="description" content="In Engs 50 you will learn how to design & build large, reliable, maintainable, and understandable software systems.  In the process you will learn to program in C with Unix development tools.
">

  <link rel="shortcut icon" href="/engs50/50.png" />
  <link rel="stylesheet" href="/engs50/css/main.css">
<<<<<<< HEAD
  <link rel="canonical" href="/engs50/Notes/cohesion/">
=======
<<<<<<< HEAD
  <link rel="canonical" href="/engs50/Notes/iterators/">
=======
  <link rel="canonical" href="/engs50/Notes/cohesion/">
>>>>>>> 985afc6cf80cf3f1b063d810d5574da861fac1cf
>>>>>>> 384f1e5bd435ca42f571d4856ac38fdd79014ca8
</head>


  <body>

    <header class="site-header">

    <a class="site-title" href="/engs50/">
      <img width=48 align=center src="/engs50/50.png" alt="icon">
      Engs50 (CS50)
    </a>

    <nav class="site-nav">
      [<a href="/engs50/Labs/">Labs</a>]
      [<a href="/engs50/Notes/">Notes</a>]
      [<a href="/engs50/Reading/">Reading</a>]
      [<a href="/engs50/Resources/">Resources</a>]
			[<a href="/engs50/Examples/">Examples</a>]
   </nav>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
<<<<<<< HEAD
=======
<<<<<<< HEAD
    <h1 class="post-title">Iterators</h1>
  </header>

  <div class="post-content">
    <p>In this lecture, we will learn about <em>Iterators</em> and their uses:</p>

<ul>
  <li>what is an Iterator</li>
  <li>how is it coded in the context of our data structures</li>
  <li>how it leverages function pointers in C</li>
  <li>passing arguments to interators</li>
  <li>several uses of iterators</li>
</ul>

<h2 id="why-iterators">Why iterators?</h2>

<p><em>Iterators</em> are a powerful concept, especially when writing an abstract data structure that represents a collection.
We have several such data structures - tree, bag, set, hashtable, and counters.
If the collection implements an <em>iterator</em>, we can apply some function to every item in that collection…
e.g., for printing, counting, modifying, and even combining multiple collections.</p>

<p>In Lab 5 you will find iterators helpful in writing the contents of the Index to the index file.</p>

<p>In Lab 6 you will find iterators helpful in combining the set of matches for one word with the set of matches for another word.</p>

<h2 id="coding-an-iterator">Coding an iterator</h2>

<p>Lab 3 asked you to include an <code class="highlighter-rouge">_iterate()</code> method in each of <code class="highlighter-rouge">set</code>, <code class="highlighter-rouge">hashtable</code>, and <code class="highlighter-rouge">counters</code>.
You saw the <code class="highlighter-rouge">bag_iterate()</code> method as an example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Iterate over the whole bag; call the given function on each item,
 * passing both the item and an argument. Ignore if NULL bag or NULL itemfunc.
 */</span>
<span class="kt">void</span>
<span class="nf">bag_iterate</span><span class="p">(</span><span class="n">bag_t</span> <span class="o">*</span><span class="n">bag</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">itemfunc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bag</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">itemfunc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// call itemfunc with arg, on each item
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">bagnode_t</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">bag</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="n">itemfunc</span><span class="p">)(</span><span class="n">arg</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that the code begins with defensive programming - in case the caller accidentally calls us with NULL parameters.</p>

<p>Otherwise, the function is a simple <code class="highlighter-rouge">for</code> loop, stepping through each item in the bag.
This iterator makes no promise about the <em>order</em> in which it processes items; after all, a ‘bag’ is an unordered, unlabeled collection of ‘things’.</p>

<h2 id="function-pointers">Function pointers</h2>

<p>Recall our discussion of <em>function pointers</em> from earlier in the term.
The second parameter to <code class="highlighter-rouge">bag_iterate</code> declares <code class="highlighter-rouge">itemfunc</code> as a <em>pointer to a function</em> that itself takes two parameters: an <code class="highlighter-rouge">arg</code> and a <code class="highlighter-rouge">data</code>.
Both are void pointers, that is, pointers to <em>some unspecified type</em>.
Because the iterator receives a function pointer from its caller, and the arg/data parameters are arbitrary pointers, this iterator can work on items of any type, and compute any sort of function on those items, making it truly general-purpose.</p>

<p>Look inside the <code class="highlighter-rouge">for</code> loop, where we call <code class="highlighter-rouge">itemfunc</code>.
Here, we dereference the <em>function pointer</em> to get a <em>function</em>, then call it with two parameters: the <code class="highlighter-rouge">arg</code> provided to us, and the data for this item.
(Syntactically, we have to wrap the dereference in parentheses, but otherwise, it’s just like any other function call.)</p>

<h2 id="arguments">Arguments</h2>

<p>Sometimes, though not always, the caller will need a way of communicating other information to the <code class="highlighter-rouge">itemfunc</code> - not just the information about the item our iterator can provide.
Thus, the iterator takes <code class="highlighter-rouge">arg</code>, a pointer to arbitrary something, and passes it right on through to the <code class="highlighter-rouge">itemfunc</code>.
This mechanism is general-purpose:</p>

<ul>
  <li>pass <code class="highlighter-rouge">arg=NULL</code> if the caller has no need to send additional arguments to its <code class="highlighter-rouge">itemfunc</code>;</li>
  <li>pass a pointer to a simple variable if the caller just needs to get information into the <code class="highlighter-rouge">itemfunc</code>;</li>
  <li>indeed, in that case, the variable is passed <em>by reference</em> and thus the <code class="highlighter-rouge">itemfunc</code> can update the variable if needed;</li>
  <li>furthermore, if the caller needs to send multiple things to the <code class="highlighter-rouge">itemfunc</code>, it can pass a pointer to a <code class="highlighter-rouge">struct</code> holding those things.</li>
</ul>

<p>We’ll see examples by writing some code that uses our <code class="highlighter-rouge">bag_iterate()</code> and my <code class="highlighter-rouge">set_iterate()</code> functions.</p>

<h2 id="examples-with-bag_iterate">Examples with bag_iterate()</h2>

<p>Three examples from <a href="/engs50/Labs/Lab3/starter/bag/bagtest.c">bagtest.c</a>.</p>

<p><strong><em>Printing.</em></strong>
First, let’s suppose we don’t have (or don’t like) the existing <code class="highlighter-rouge">bag_print()</code> method, which tends to print some text/formatting around each item.
We can use our new iterator:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Simpleprint:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">bag_iterate</span><span class="p">(</span><span class="n">bag</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">simpleprint</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">...</span>

<span class="cm">/* print the given item to the given file;
 * just print the stock symbol
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">simpleprint</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">stock</span> <span class="o">*</span><span class="n">stp</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">stp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%s "</span><span class="p">,</span> <span class="n">stp</span><span class="o">-&gt;</span><span class="n">symbol</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, we pass the file pointer through the <code class="highlighter-rouge">arg</code> parameter.
Notice how <code class="highlighter-rouge">simpleprint</code> immediately copies its <code class="highlighter-rouge">arg</code>, <code class="highlighter-rouge">data</code> parameters into local variables of the right type.
That gives them more readable names, allows the compiler to check the code that follows, and allows us to use structure pointers (like <code class="highlighter-rouge">stp</code>) to reach members of those structures.</p>

<p><strong><em>Counting.</em></strong>
Even simpler, we could just count the items.
But where do we put the counter?
Define a local variable and pass its address as the <code class="highlighter-rouge">arg</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Count: "</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">nitems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">bag_iterate</span><span class="p">(</span><span class="n">bag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nitems</span><span class="p">,</span> <span class="n">itemcount</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nitems</span><span class="p">);</span>
<span class="p">...</span>

<span class="cm">/* count the non-null items in the bag.
 * note here we don't care what kind of item is in bag.
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">itemcount</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">nitems</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">nitems</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">(</span><span class="o">*</span><span class="n">nitems</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Multiple arguments.</em></strong>
What if we want two counters?
In this version of <code class="highlighter-rouge">bagtest</code> I read in stock quotes: symbol, previous closing price, current price, and trading volume.
Let’s just count the number of gainers and number of losers.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a little structure to carry two counters.
</span><span class="k">struct</span> <span class="n">gainloss</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ngainers</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nlosers</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Changes: "</span><span class="p">);</span>
  <span class="k">struct</span> <span class="n">gainloss</span> <span class="n">changes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">bag_iterate</span><span class="p">(</span><span class="n">bag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">changes</span><span class="p">,</span> <span class="n">stockgainloss</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"gainers: %d; losers: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">changes</span><span class="p">.</span><span class="n">ngainers</span><span class="p">,</span> <span class="n">changes</span><span class="p">.</span><span class="n">nlosers</span><span class="p">);</span>
<span class="p">...</span>

<span class="cm">/* count the number of gainers and losers.
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">stockgainloss</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">gainloss</span> <span class="o">*</span><span class="n">gl</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">stock</span> <span class="o">*</span><span class="n">stp</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">gl</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">stp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stp</span><span class="o">-&gt;</span><span class="n">price</span> <span class="o">&gt;</span> <span class="n">stp</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
      <span class="n">gl</span><span class="o">-&gt;</span><span class="n">ngainers</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stp</span><span class="o">-&gt;</span><span class="n">price</span> <span class="o">&lt;</span> <span class="n">stp</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
      <span class="n">gl</span><span class="o">-&gt;</span><span class="n">nlosers</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Once the stucture is defined, our use of iterator is very much like the previous example.
We define and initialize a local variable, pass a pointer to that variable as our <code class="highlighter-rouge">arg</code>, and then the <code class="highlighter-rouge">itemfunc</code> copies that pointer into a pointer of the relevant type so it can access (and update) the contents.
<em>Notice that it is not necessary to <code class="highlighter-rouge">malloc</code> space in order to pass a pointer to the iterator</em> - in this example, <code class="highlighter-rouge">&amp;changes</code> is a pointer to a local variable.</p>

<h2 id="examples-with-set_iterate">Examples with set_iterate()</h2>

<p>The ‘bag’ module is nice because it is very simple, but we can do more interesting things when the items have a <code class="highlighter-rouge">key</code> as well.
Let’s use <code class="highlighter-rouge">set_iterate</code> for two examples.</p>

<p>See my terminal <a href="/engs50/Notes/iterators/script.txt">script</a> for the code and a test run.</p>

<p><strong><em>Merging two sets.</em></strong>
We’ll start with a simple case.
Here the sets represent schools, where the <code class="highlighter-rouge">key</code> is the name of the school.
See <a href="/engs50/Examples/set_iterate1.c">set_iterate1</a>.
(Note also <a href="/engs50/Examples/set_iterate.makefile">set_iterate.makefile</a>.)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">set_t</span> <span class="o">*</span><span class="n">setA</span><span class="p">,</span> <span class="o">*</span><span class="n">setB</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>     <span class="c1">// three sets
</span><span class="p">...</span> <span class="n">initialize</span> <span class="n">each</span> <span class="n">set</span> <span class="n">with</span> <span class="n">set_new</span>
<span class="p">...</span> <span class="n">fill</span> <span class="n">setA</span> <span class="n">and</span> <span class="n">setB</span> <span class="n">with</span> <span class="n">set_insert</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Merge of setA into result: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">set_merge</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">setA</span><span class="p">);</span>
  <span class="n">set_print</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">itemprint</span><span class="p">);</span>
  <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Merge of setB into result: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">set_merge</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">setB</span><span class="p">);</span>
  <span class="n">set_print</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">itemprint</span><span class="p">);</span>
  <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
<span class="p">...</span>

<span class="cm">/* Merge the second set into the first set;
 * the second set is unchanged.
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">set_merge</span><span class="p">(</span><span class="n">set_t</span> <span class="o">*</span><span class="n">setA</span><span class="p">,</span> <span class="n">set_t</span> <span class="o">*</span><span class="n">setB</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">set_iterate</span><span class="p">(</span><span class="n">setB</span><span class="p">,</span> <span class="n">setA</span><span class="p">,</span> <span class="n">set_merge_helper</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Consider one item for insertion into the other set.
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">set_merge_helper</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">set_t</span> <span class="o">*</span><span class="n">setA</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">set_insert</span><span class="p">(</span><span class="n">setA</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">%s added</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">%s exists</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Notice how the above approach iterates over one set (setB) and, for each item in that set, tries to insert or update its value in the first set (setA).
At the end, setB is unchanged but setA should have all items from both sets.</p>

<p><strong><em>Merging two sets and their data.</em></strong>
Now a more interesting case, in which the set items each hold data we want to combine.
In this simple test, that datum is just an integer - actually, a pointer to an integer.
See <a href="/engs50/Examples/set_iterate2.c">set_iterate2</a>.
(Note also <a href="/engs50/Examples/set_iterate.makefile">set_iterate.makefile</a>.)</p>

<p>In this example, setA and setB each contain a set of school names, and a number for each school (say, perhaps, the number of people you know at each school).
When merging two sets you want the data in the resulting set to represent the sum of the values in each set.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">set_insert</span><span class="p">(</span><span class="n">setA</span><span class="p">,</span> <span class="s">"Dartmouth"</span><span class="p">,</span> <span class="n">intsave</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="p">...</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Merge of setA into result: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">set_merge</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">setA</span><span class="p">);</span>
  <span class="n">set_print</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">itemprint</span><span class="p">);</span>
  <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Merge of setB into result: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">set_merge</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">setB</span><span class="p">);</span>
  <span class="n">set_print</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">itemprint</span><span class="p">);</span>
  <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
<span class="p">...</span>

<span class="cm">/* Merge the second set into the first set;
 * the second set is unchanged.
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">set_merge</span><span class="p">(</span><span class="n">set_t</span> <span class="o">*</span><span class="n">setA</span><span class="p">,</span> <span class="n">set_t</span> <span class="o">*</span><span class="n">setB</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">set_iterate</span><span class="p">(</span><span class="n">setB</span><span class="p">,</span> <span class="n">setA</span><span class="p">,</span> <span class="n">set_merge_helper</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Consider one item for insertion into the other set.
 * If the other set does not contain the item, insert it;
 * otherwise, update the other set's item with sum of item values.
 */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">set_merge_helper</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">set_t</span> <span class="o">*</span><span class="n">setA</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">itemB</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
  
  <span class="c1">// find the same key in setA
</span>  <span class="kt">int</span> <span class="o">*</span><span class="n">itemA</span> <span class="o">=</span> <span class="n">set_find</span><span class="p">(</span><span class="n">setA</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">itemA</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// not found: insert it
</span>    <span class="n">set_insert</span><span class="p">(</span><span class="n">setA</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">intsave</span><span class="p">(</span><span class="o">*</span><span class="n">itemB</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">%s added</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// add to the existing value
</span>    <span class="o">*</span><span class="n">itemA</span> <span class="o">+=</span> <span class="o">*</span><span class="n">itemB</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">%s exists</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span>
<span class="n">intsave</span><span class="p">(</span><span class="kt">int</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">saved</span> <span class="o">=</span> <span class="n">assertp</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="s">"intsave"</span><span class="p">);</span>
  <span class="o">*</span><span class="n">saved</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">saved</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The overall structure of the code is identical to the prior example; the difference here is that we need to look up the key in the destination set first and then perhaps update its data - because we get a <em>pointer</em> to the data, we can easily reach in and update its value!</p>

<h2 id="summary">Summary</h2>

<p>Iterators are super powerful.  Function pointers are great!</p>

<h2 id="activity">Activity</h2>

<p>You’ve now seen how to construct the <em>union</em> of two sets.
In today’s <a href="activity.html">activity</a> your group discusses how you would construct the <em>intersection</em> of two sets - it’s very analogous, but a bit trickier.
(I found that the <code class="highlighter-rouge">itemfunc</code> needed a pointer to each set, not just the one set, as in the example above.)</p>
=======
>>>>>>> 384f1e5bd435ca42f571d4856ac38fdd79014ca8
    <h1 class="post-title">Cohesion and coupling</h1>
  </header>

  <div class="post-content">
    <h3 id="goals">Goals</h3>

<p>to discuss</p>

<ul>
  <li><em>routines</em> - types and names</li>
  <li><em>cohesion</em> - and why we want strong cohesion</li>
  <li><em>coupling</em> - and why we want weak coupling</li>
</ul>

<p>The concepts in today’s lecture come from chapter 5 of <em>Code Complete</em> by Steve McConnell. [Microsoft Press, 1993.]</p>

<h2 id="routines">Routines</h2>

<p>We often use the word <em>routine</em> as a general concept, to refer to  a <em>function</em> or a <em>procedure</em>.
We typically use the word <em>procedure</em> to refer to a function with no return value.
In other languages, routines might be called <em>subroutines</em> or <em>methods</em>.</p>

<p>There are many reasons to break a program into <em>routines</em>:</p>

<ul>
  <li>Reduce complexity</li>
  <li>Avoid duplicate code</li>
  <li>Limit effects of changes (narrow scope of change to a routine)</li>
  <li>Hide sequences (a form of information hiding)</li>
  <li>Improve performance (optimize in one place)</li>
  <li>Centralize control (e.g., controlling devices, files, data structures… more information hiding)</li>
  <li>Hide data structures (ADTs)</li>
  <li>Hide global data (access routines centralize control of globals)</li>
  <li>Hide pointer operations (makes it easier to read)</li>
  <li>Promote code reuse (easier to reuse code in a routine)</li>
  <li>Plan for a family of programs (isolate parts that may change in a few routines)</li>
  <li>Improve readability (named routine is more readable; avoid deep nesting, etc)</li>
  <li>Improve portability (isolate nonportable features)</li>
  <li>Isolate complex operations (algorithm, protocols, etc)</li>
  <li>Isolate use of nonstandard language functions (isolate nonportable features)</li>
  <li>Simplify complicated boolean tests (inlines are great here)</li>
</ul>

<p>Routines should be well named:</p>

<ul>
  <li>a <em>procedure</em> name should be a strong verb followed by object (like <em>printCalendar()</em>).</li>
  <li>a <em>function</em> name should describe its return value (like <em>numberOfNonzeros()</em>).</li>
  <li>a <em>boolean function</em> name should sound like a question (like <em>IsInternalURL()</em>).</li>
</ul>

<p>A good routine name</p>

<ul>
  <li>avoids meaningless verbs (like <em>do</em>, <em>perform</em>)</li>
  <li>describes everything the routine does</li>
  <li>is as long as necessary</li>
  <li>follows naming conventions!</li>
</ul>

<p>A routine’s body should not be <strong>too long</strong>.
If you find your routine approaching 200 lines, you should break it up - or have a darn good reason you should not break it up.</p>

<h3 id="cohesion">Cohesion</h3>

<blockquote>
  <p>“Cohesion refers to how closely [or strongly] the operations in a routine are related.” – McConnell</p>
</blockquote>

<p>One study found that 50% of high-cohesion routines were fault-free, while 18% of low-cohesion routines were fault-free.</p>

<p>Good routines have <strong><em>strong cohesion</em></strong>.</p>

<p><strong>Acceptable cohesion</strong>:</p>

<ul>
  <li><strong>Functional cohesion</strong> (strongest and best kind): performs one and only one operation.</li>
  <li><strong>Sequential cohesion</strong>: contains operations that must be performed in a sequential order.</li>
  <li><strong>Communicational cohesion</strong>: contains operations that make use of the same data, but are not otherwise related.</li>
  <li><strong>Temporal cohesion</strong>: contains operations that do several things, because all are done at the same time.</li>
</ul>

<p><strong>Unacceptable cohesion</strong>:</p>

<ul>
  <li><strong>Procedural cohesion</strong>: contains operations that must be performed in a sequential order, but don’t share the same data.</li>
  <li><strong>Logical cohesion</strong>: several things in a routine, only one executed, depending on a flag parameter.
(Exception - it can be  ok if using a <code class="highlighter-rouge">switch</code> statement to call one of many other (cohesive) functions.)</li>
  <li><strong>Coincidental cohesion</strong>: no apparent reason for things to be together in a routine!</li>
</ul>

<h3 id="coupling">Coupling</h3>

<blockquote>
  <p>“The degree of coupling refers to the strength of a connection between two routines. Coupling is a complement to cohesion.” – McConnell</p>
</blockquote>

<p>Good code has <strong><em>loose coupling</em></strong> among routines.</p>

<blockquote>
  <p>“Make the coupling of routines as simple as possible.”</p>
</blockquote>

<p><strong>Criteria</strong> for evaluating coupling between routines:</p>

<ul>
  <li><strong>size</strong> (number of connections)</li>
  <li><strong>intimacy</strong> (directness of connection; better to use direct parameter passing than indirect global variables)</li>
  <li><strong>visibility</strong> (best if connection is obvious)</li>
  <li><strong>flexibility</strong> (how easily you can change connections)</li>
</ul>

<p>Go for minimal interconnectedness, and make what interconnections you have simple and obvious.
“If a program were a piece of wood, you’d try to split it with the grain.”</p>

<h4 id="kinds-of-coupling">Kinds of coupling</h4>

<ul>
  <li><strong>Simple-data coupling</strong>: the only data passed from one routine to another is through parameters, and is nonstructured.</li>
  <li><strong>Data-structure coupling</strong>: one routine passes a data structure to another; best if it really needs the whole data structure.</li>
  <li><strong>Control coupling</strong>: one routine tells the other what to do.</li>
  <li><strong>Global-data coupling</strong>: two routines use the same global data; may be tolerable if read-only.</li>
  <li><strong>Pathological coupling</strong>: one routine uses the data inside the other routine. (Somewhat hard to do in C and C++.)</li>
</ul>

<blockquote>
  <p>“Try to create routines that depend little on other routines.”</p>
</blockquote>

<h4 id="defensive-programming">Defensive programming</h4>

<p>Best practices:</p>

<ul>
  <li>Use assert() or other tests to insert sanity checks into your code.</li>
  <li>Be particularly suspicious of parameters and input values that come from another module (including the user!), i.e., data that crosses a module interface.</li>
</ul>

<h4 id="routine-parameters">Routine parameters</h4>

<p>Best practices:</p>

<ul>
  <li>Put parameters in input-modify-output order; put “status” or “error” variables last.</li>
  <li>Use all the parameters.</li>
  <li>Use a consistent order among similar routines.</li>
  <li>Document assumptions about parameters: <em>Preconditions</em> are assumptions about the parameters (or internal data-structure state) before the routine executes, and <em>postconditions</em> are assumptions about the parameters, data structure, and return value after the routine exits.</li>
</ul>

<h4 id="macros">Macros</h4>

<p>You can write <em>macros</em> in C with #define - these are handled by the C preprocessor.
Macros can be handy, on occasion, but it is usually better to use <code class="highlighter-rouge">inline</code> functions or <code class="highlighter-rouge">const</code> variables for these purposes.
You get better syntax, type checking, and better debugger support.</p>

<h2 id="modules">Modules</h2>

<p>A <em>module</em> is a collection of related routines that, together, encapsulate a data structure, subsystem, or task.
In object-oriented programming, a module is typically called a <em>class</em>.</p>

<p>Why modules?</p>

<ul>
  <li>It is sometimes necessary to have strong coupling between routines.</li>
  <li>In that case you should group those routines into a <em>module</em>; the module has strong cohesion.</li>
  <li>Strive for strong intra-module cohesion and loose inter-module coupling.</li>
  <li>A well-designed module (in C) or class (in C++ or Java) encourages <em>information hiding</em>.</li>
</ul>

<h4 id="information-hiding">Information hiding</h4>

<p>A good module serves to “hide” implementation details inside the module, providing a clean abstraction and clear interface to other modules.</p>

<p>Each module programmer makes many implementation decisions, which should largely be unknown to code outside the module.
Thus the module is</p>

<ul>
  <li>less coupled to others,</li>
  <li>more maintainable,</li>
  <li>more self-testable,</li>
  <li>more replacable,</li>
  <li>more debuggable (can insert debugging code easily),</li>
  <li>more reliable (can insert checks in a few places),</li>
  <li>more understandable (hides complexity).</li>
</ul>

<h4 id="collaborative-work">Collaborative work</h4>

<p>Modules (classes) are an excellent mechanism for dividing work among programmers, because module boundaries and interfaces are clear, and there is otherwise little coupling.
Thus, the module programmer has wide flexibility and authority on the implementation details of her module, as long as she sticks to the agreed-upon interface for the module and clearly documents the interface.</p>

<h2 id="activity">Activity</h2>

<p>In today’s <a href="activity.html">activity</a> your group will look at some <a href="/engs50/Notes/cohesion/example.c">example</a> code and comment on its naming, cohesion, and coupling.</p>
<<<<<<< HEAD
=======
>>>>>>> 985afc6cf80cf3f1b063d810d5574da861fac1cf
>>>>>>> 384f1e5bd435ca42f571d4856ac38fdd79014ca8

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Engs50 (CS50) -- Dartmouth College</h2>

    <p> <font size=-1>
    	This version of the course is based upon those designed by
    	Professors Palmer, Kotz, Zhou, Campbell, and Balkcom.
	I am deeply indebted to these outstanding educators.
    -- <a href="https://engineering.dartmouth.edu/people/faculty/stephen-taylor/">Stephen Taylor</a>
       </font>
    </p>
    <p><small>This page was last updated on <strong>2018-10-10</strong> at <strong>18:07</strong>.</small></p>
  </div>

</footer>


  </body>

</html>
